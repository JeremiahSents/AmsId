package dev.sentomero.backend_ams.service.impl;

import dev.sentomero.backend_ams.service.SerialNumberService;
import dev.sentomero.backend_ams.repository.KpClientRepository;
import jakarta.persistence.EntityManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;


import java.util.Optional;

@Service
@Transactional
public class SerialNumberServiceImpl implements SerialNumberService {
    private static final long STARTING_SERIAL = 5000L;
    private static final long MAX_SERIAL = 99999L;

    private final KpClientRepository kpClientRepository;
    private final EntityManager entityManager;

    @Autowired
    public SerialNumberServiceImpl(KpClientRepository kpClientRepository, EntityManager entityManager) {
        this.kpClientRepository = kpClientRepository;
        this.entityManager = entityManager;
    }

    @Override
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public Long generateSerialNumber() {
        // Create a pessimistic lock
        entityManager.createNativeQuery("SELECT pg_advisory_xact_lock(123456)").executeUpdate();

        // Get the highest serial number currently in use
        Optional<Long> maxSerial = kpClientRepository.findHighestSerialNumber();

        // If no serial numbers exist, start from STARTING_SERIAL
        long nextSerial = maxSerial.map(serial -> serial + 1)
                .orElse(STARTING_SERIAL);

        // If we've reached the maximum, look for gaps
        if (nextSerial > MAX_SERIAL) {
            Optional<Long> gap = findFirstAvailableGap();
            if (gap.isPresent()) {
                nextSerial = gap.get();
            } else {
                throw new IllegalStateException("No available serial numbers in the valid range");
            }
        }

        // Double-check the number isn't in use
        if (kpClientRepository.existsBySerialNumber(nextSerial)) {
            // If it exists, recursively try to get the next available number
            return generateSerialNumber();
        }

        return nextSerial;
    }

    private Optional<Long> findFirstAvailableGap() {
        var usedSerials = kpClientRepository.findAllSerialNumbersOrdered();

        long expectedSerial = STARTING_SERIAL;
        for (Long usedSerial : usedSerials) {
            if (expectedSerial < usedSerial) {
                return Optional.of(expectedSerial);
            }
            expectedSerial = usedSerial + 1;
        }

        return Optional.empty();
    }
}